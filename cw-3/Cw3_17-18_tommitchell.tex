\documentclass[11pt]{article}

% Change page boundaries
\usepackage[top=3cm, bottom=3cm, left=3cm, right=3cm]{geometry}

% Header and footer customisation
\usepackage{fancyhdr}
\pagestyle{fancyplain}
\usepackage{lastpage}
\usepackage{pdflscape}

% Reset headers and footers
\fancyhf{}

% Headers
\lhead{SDCAI CW 3}
\rhead{Prolog and Generate-And-Test}

% Footers
\renewcommand{\footrulewidth}{0.4pt}
\lfoot{Tom Mitchell}
\cfoot{\thepage\ of \pageref{LastPage}}
\rfoot{16010488}

% Remove paragraph indenting
\setlength{\parindent}{0pt}


% BEGIN
\begin{document}

% TITLE PAGE
\begin{titlepage}
\newgeometry{top=5cm, bottom=5cm, left=3cm, right=3cm}
\begin{center}

\huge{Symbolic and Declarative Computing \& AI} \\
\Huge{\textbf{Prolog and Generate-And-Test}} \\


\vfill
\LARGE{Tom Mitchell} \\
\LARGE{16010488} \\
\LARGE{AY 2017 - 2018}

\end{center}
\end{titlepage}


% CONTENTS
\newgeometry{top=3cm, bottom=3cm, left=3cm, right=3cm}
\tableofcontents
\newpage

\section{Discussion of frequently used predicates}
\subsection{bagof/3}
As per the Prolog documentation, the predicate {\verb|bagof(+Template, :Goal, -Bag)|} works by unifying {\verb|Bag|} with all permutations of {\verb|Template|} with the free variables in {\verb|Goal|}. Consider a Prolog database file, the contents of which are shown below.
\begin{verbatim}
foo(a). foo(b).
bar(1). bar(2).
\end{verbatim}

The following interactive session with this file demonstrates the functionality of {\verb|bagof/3|}:
\begin{verbatim}
?- listing(foo).
foo(a).
foo(b).

true.

?- listing(bar).
bar(1).
bar(2).

true.

?- bagof((X, Y), (foo(X), bar(Y)), Ps).
Ps = [(a, 1),  (a, 2),  (b, 1),  (b, 2)].

?- bagof((X, Y), (foo(X), bar(Y), X \= a), Ps).
Ps = [(b, 1),  (b, 2)].
\end{verbatim}

As you can see, all permutations of the pattern {\verb|(F, B)|} have been generated and unified with {\verb|Ps|}, where the variable {\verb|F = a|} or {\verb|b|}, and  {\verb|B = 1|} or {\verb|2|}.  \\

It is important to note that other predicates in the goal are also observed when generating permutations. In the interactive session above, we see the term {\verb|X \= a|} prevents any permutation where {\verb|X == a|} from being unified.

\newpage
\subsection{is\_element/2}
The predicate {\verb|is_element/2|}, as defined in the coursework specification, can be used (usefully) in two "modes", first of which is the {\verb|(+, +)|} mode. In this mode, both an element and a list are given, and the status of the elements membership in a list will be returned. This behaviour is shown in the interactive session below.
\begin{verbatim}
?- is_element(4, [1, 2, 3, 4]).
true .

?- is_element(5, [1, 2, 3, 4]).
false.
\end{verbatim}

The second mode is the {\verb|(-, +)|} mode. Given a list and an unbound variable, Prolog will use backtracking to unify the variable with every element in the list. This proves useful when attempting to retrieve all values from a given list, as shown below.
\begin{verbatim}
?- is_element(N, [1, 2, 3, 4]).
N = 1 ;
N = 2 ;
N = 3 ;
N = 4 ;
false.
\end{verbatim}

While {\verb|is_element/2|} can also be used in the {\verb|(+, -)|} mode, this generates the given element as part of list containing only anonymous elements, which I do not find to be of any particular use.
\begin{verbatim}
?- P = a, is_element(4, L).
P = a,
L = [4|_9056] ;
P = a,
L = [_9054, 4|_9062] ;
P = a,
L = [_9054, _9060, 4|_9068] ;
P = a,
L = [_9054, _9060, _9066, 4|_9074] .
\end{verbatim}

It is worth noting that {\verb|is_element/2|} and {\verb|member/2|} work in the same way.

\newpage
\section{Tasks}

% TASK 1
\subsection{Task 1 - allhousepairs/1}
\textbf{Source code:}
\begin{verbatim}
allhousepairs(Ps) :- 
    bagof(
        p(P, C), 
        (
           (people(Xs), is_element(P, Xs)), 
           (cols(Ys), is_element(C, Ys))
        ), 
        Ps
    ).
\end{verbatim}

\textbf{Explanation:} \\
{\verb|allhousepairs/1|} generates the Cartesian product of the lists of people and colours using {\verb|bagof/3|}. \\

The goal is generated by unifying {\verb|Xs|} with {\verb|[a, b, c]|}, and {\verb|Ys|} with {\verb|[green, red, yellow]|}. {\verb|is_element/2|} is used to produce an element from each list - backtracking to ensure all permutations are accounted for. The produced elements are unified with {\verb|P|} and {\verb|C|} respectively, and the pattern {\verb|p(P, C)|} is added to the bag {\verb|Ps|}. \\

When all backtracking is exhausted, all possible pairs of houses and people will have been generated. The cardinality of a set Cartesian pairs generated from sets $A$ and $B$ will be $|A| \times |B|$, so we can expect the size of the resultant list {\verb|Ps|} to be 9 ($3 \times 3$) elements in length, all of which are unique. The demonstration below show that this predicate works as expected. \\


\textbf{Testing:}
\begin{verbatim}
?- allhousepairs(Ps).
Ps = [p(a, green), p(a, red), p(a, yellow), 
      p(b, green), p(b, red), p(b, yellow), 
      p(c, green), p(c, red), p(c, yellow)].

?- allhousepairs(_Ps), length(_Ps, L).
L = 9.

?- allhousepairs(_Ps), list_to_set(_Ps, _Ss), _Ps == _Ss.
true.
\end{verbatim}
\newpage

% TASK 2
\subsection{Task 2 - all\_triplets/1}
\textbf{Source code:}
\begin{verbatim}
all_triplets(Ts) :-
    bagof(
        (p(P1, C1), p(P2, C2), p(P3, C3)),
        (
            (
                allhousepairs(Ps),
                is_element(p(P1, C1), Ps), 
                is_element(p(P2, C2), Ps),
                is_element(p(P3, C3), Ps)  
            ),
            (
              (P1 \= P2, P2 \= P3, P3 \= P1),
              (C1 \= C2, C2 \= C3, C3 \= C1)
            )
       ),
       Ts
   ).
\end{verbatim}

\textbf{Explanation:} \\
As is described in the coursework briefing, we wish to generate a list of "occupancy triplets" in the pattern {\verb|(p(P1, C1), p(P2, C2), p(P3, C3))|}. Naturally, this pattern is what will be used as the first argument to the {\verb|bagof/3|} predicate. \\

To generate the three {\verb|P|} and three {\verb|C|} variables, we will first use {\verb|allhousepairs/1|} to unify {\verb|Ps|} with the list of person/house combinations. Using {\verb|is_element/2|}, the three {\verb|P|} and {\verb|C|} pairs are unified with the house patterns in {\verb|Ps|}. \\

We also take advantage of {\verb|bagof/3|}'s observation of other predicates in the goal to confirm that three people and colours we have retrieved are unique. This is done by comparing all three with the infix {\verb|\=/2|} predicate. If all three are not unique, the permutation is not added to the bag. \\

For any given house, there are 4 occupancy triplets where that house is the first. Once the first pair in a triplet is decided, there are 2 colours and 2 people to chose from - giving us 4 permutations (Cartesian products are discussed in section 2.1). Because there are 9 pairs, we expect to see 36 ($9 \times 4$) elements in the list unified with {\verb|Ts|}.

\newpage
\textbf{Testing:}
\begin{verbatim}
?- all_triplets(Ts).
Ts = [(p(a, green), p(b, red), p(c, yellow)), 
      (p(a, green), p(b, yellow), p(c, red)), 
      (p(a, green), p(c, red), p(b, yellow)), 
      (p(a, green), p(c, yellow), p(b, red)), 
      (p(a, red), p(b, green), p(c, yellow)), 
      (p(a, red), p(b, yellow), p(c, green)), 
      (p(a, red), p(c, green), p(b, yellow)), 
      (p(a, red), p(c, yellow), p(b, green)), 
      (p(a, yellow), p(b, green), p(c, red)), 
      (p(a, yellow), p(b, red), p(c, green)), 
      (p(a, yellow), p(c, green), p(b, red)), 
      (p(a, yellow), p(c, red), p(b, green)), 
      (p(b, green), p(a, red), p(c, yellow)), 
      (p(b, green), p(a, yellow), p(c, red)), 
      (p(b, green), p(c, red), p(a, yellow)), 
      (p(b, green), p(c, yellow), p(a, red)), 
      (p(b, red), p(a, green), p(c, yellow)), 
      (p(b, red), p(a, yellow), p(c, green)), 
      (p(b, red), p(c, green), p(a, yellow)), 
      (p(b, red), p(c, yellow), p(a, green)), 
      (p(b, yellow), p(a, green), p(c, red)), 
      (p(b, yellow), p(a, red), p(c, green)), 
      (p(b, yellow), p(c, green), p(a, red)), 
      (p(b, yellow), p(c, red), p(a, green)), 
      (p(c, green), p(a, red), p(b, yellow)), 
      (p(c, green), p(a, yellow), p(b, red)), 
      (p(c, green), p(b, red), p(a, yellow)), 
      (p(c, green), p(b, yellow), p(a, red)), 
      (p(c, red), p(a, green), p(b, yellow)), 
      (p(c, red), p(a, yellow), p(b, green)), 
      (p(c, red), p(b, green), p(a, yellow)), 
      (p(c, red), p(b, yellow), p(a, green)), 
      (p(c, yellow), p(a, green), p(b, red)), 
      (p(c, yellow), p(a, red), p(b, green)), 
      (p(c, yellow), p(b, green), p(a, red)), 
      (p(c, yellow), p(b, red), p(a, green))].

?- all_triplets(_Ts), length(_Ts, L).
L = 36.

?- all_triplets(_Ts), list_to_set(_Ts, _Ss), _Ts == _Ss.
true.

\end{verbatim}
\newpage

% TASK 3
\subsection{Task 3 - lives\_pattern/3}
\textbf{Source code:}
\begin{verbatim}
lives_pattern((p(Person, Colour), _, _), Colour, Person).
lives_pattern((_, p(Person, Colour), _), Colour, Person).
lives_pattern((_, _, p(Person, Colour)), Colour, Person).
\end{verbatim}

\textbf{Explanation:} \\
This predicate is most usefully used in either the {\verb|(+,+,-)|} or the {\verb|(+,-,+)|} modes to retrieve either the person or colour for a given house, provided a given person and colour to identify the house. It can also be used to determine whether a specific house is present in the triplet using the {\verb|(+,+,+)|} mode. \\

Whichever variable is provided is unified with it's equivalent in the housing triplet (failing when it cannot unify, and then trying the next version of the predicate when applicable). The free variable is then unified with with the other section in the "house". In the case of the {\verb|(+,+,+)|} mode, both variables attempt to unify with their respective others on each house. \\

Consider an example where the given triplet is {\verb|(p(b, red), p(c, green), p(a, yellow))|}, and where {\verb|Colour|} is unified with {\verb|yellow|}. The first two attempts at unifying {\verb|Person|} will fail, as the yellow house is the third house in the triplet. In the third variant of {\verb|lives_pattern/3|}, {\verb|Colour|} can be unified with {\verb|yellow|}, and so {\verb|Person|} is unified with {\verb|a|}. \\

\textbf{Testing:}
\begin{verbatim}
?- lives_pattern((p(a, green), p(b, red), p(c, yellow)), Colour, Person).
Colour = green,
Person = a ;
Colour = red,
Person = b ;
Colour = yellow,
Person = c.

?- lives_pattern((p(a, green), p(b, red), p(c, yellow)), green, Person).
Person = a .

?- lives_pattern((p(a, green), p(b, red), p(c, yellow)), yellow, Person).
Person = c.

?- lives_pattern((p(a, green), p(b, red), p(c, yellow)), Colour, a).
Colour = green .

?- lives_pattern((p(a, green), p(b, red), p(c, yellow)), Colour, b).
Colour = red .

?- lives_pattern((p(a, green), p(b, red), p(c, yellow)), red, b).
true .
\end{verbatim}
\newpage

% TASK 4
\subsection{Task 4 - house\_info1/1}
\textbf{Source code:}
\begin{verbatim}
house_info1((p(_, C1), p(P2, C2), p(P3, _))) :-
    (C1 = yellow, P2 = a);
    (C1 = yellow, P3 = a);
    (C2 = yellow, P3 = a).
\end{verbatim}

\textbf{Explanation:} \\
{\verb|house_info1/1|} takes part of a  housing triplet and returns whether the triplet matches the criteria "A's house is to the right of the yellow house". My understanding of this was that "right of" means "both directly and indirectly to the right of". I determined three conditions where this statement can be true:
\begin{enumerate}
  \item The first house in the triplet is yellow, and A lives in the second house.
  \begin{itemize}
  \item (\_, yellow), (a, \_), (\_, \_)
  \end{itemize}
  \item The first house in the triplet is yellow, and A lives in the third house.
  \begin{itemize}
  \item (\_, yellow), (\_, \_), (a, \_)
  \end{itemize}
  \item The second house in the triplet is yellow, and A lives in the third house
  \begin{itemize}
  \item (\_, \_), (\_, yellow), (a, \_)
  \end{itemize}
\end{enumerate}
The criteria is met when $(1 \vee 2 \vee 3)$ is true, which this is reflected in the source code in the use of {\verb|;|} rather than {\verb|,|} to join the three statements. Note that the person in the first house and the colour of the third house are never used, so are substituted with wildcards in the predicate's arguments. \\

\textbf{Testing:}
\begin{verbatim}
?- bagof(T, ((all_triplets(_Ts), is_element(T, _Ts), house_info1(T))), PTs).
PTs = [(p(b, green), p(c, yellow), p(a, red)),
       (p(b, red), p(c, yellow), p(a, green)),
       (p(b, yellow), p(a, green), p(c, red)),
       (p(b, yellow), p(a, red), p(c, green)),
       (p(b, yellow), p(c, green), p(a, red)),  
       (p(b, yellow), p(c, red), p(a, green)),  
       (p(c, green), p(b, yellow), p(a, red)),  
       (p(c, red), p(b, yellow), p(a, green)),  
       (p(c, yellow), p(a, green), p(b, red)),  
       (p(c, yellow), p(a, red), p(b, green)),  
       (p(c, yellow), p(b, green), p(a, red)),  
       (p(c, yellow), p(b, red), p(a, green))].

?- bagof(T, ((all_triplets(_Ts), is_element(T, _Ts), house_info1(T))), _PTs), 
   length(_PTs, L).
L = 12.
\end{verbatim}
\newpage

% TASK 5
\subsection{Task 5 - house\_info2/1}
\textbf{Source code:}
\begin{verbatim}
house_info2((p(P1, C1), p(P2, C2), p(P3, C3))) :-
    lives_pattern((p(P1, C1), p(P2, C2), p(P3, C3)), red, b). 
\end{verbatim}

\textbf{Explanation:} \\
The second house\_info predicate determines whether a housing triplet fulfils the condition "B lives in the red house". This is achieved by using {\verb|lives_pattern/3|} to attempt to unify {\verb|Colour|} with {\verb|red|} and {\verb|Person|} with {\verb|b|}. As per the definition of {\verb|lives_pattern/3|}, all three of the triplets are "checked" individually. If the house {\verb|p(b, red)|} exists within the triplet, the unifications will succeed, returning {\verb|true|}.\\

\textbf{Testing:}
\begin{verbatim}
?- bagof(T, ((all_triplets(_Ts), is_element(T, _Ts), house_info2(T))), PTs).
PTs = [(p(a, green), p(b, red), p(c, yellow)),
       (p(a, green), p(c, yellow), p(b, red)),  
       (p(a, yellow), p(b, red), p(c, green)),  
       (p(a, yellow), p(c, green), p(b, red)),  
       (p(b, red), p(a, green), p(c, yellow)),  
       (p(b, red), p(a, yellow), p(c, green)),  
       (p(b, red), p(c, green), p(a, yellow)),  
       (p(b, red), p(c, yellow), p(a, green)),  
       (p(c, green), p(a, yellow), p(b, red)),  
       (p(c, green), p(b, red), p(a, yellow)),  
       (p(c, yellow), p(a, green), p(b, red)),  
       (p(c, yellow), p(b, red), p(a, green))].

?- bagof(T, ((all_triplets(_Ts), is_element(T, _Ts), house_info2(T))), _PTs),      
   length(_PTs, L).
L = 12.
\end{verbatim}
\newpage

% TASK 6
\subsection{Task 6 - house\_info3/1}
\textbf{Source code:}
\begin{verbatim}
house_info3((p(_, _), p(_, _), p(_, C3))) :-
    C3 \== green.
\end{verbatim}

\textbf{Explanation:} \\
The predicate {\verb|house_info3/1|} determines if a housing triplet fulfils the condition "The green house is not number 3". {\verb|C3|} is the variable used to represent the colour of the third house. We check that it is not equivalent to {\verb|green|} with the infix non-equivalency predicate {\verb|\==/2|}. \\

\textbf{Testing:}
\begin{verbatim}
?- bagof(T, ((all_triplets(_Ts), is_element(T, _Ts), house_info3(T))), PTs).    
PTs = [(p(a, green), p(b, red), p(c, yellow)),  
       (p(a, green), p(b, yellow), p(c, red)),  
       (p(a, green), p(c, red), p(b, yellow)),  
       (p(a, green), p(c, yellow), p(b, red)),  
       (p(a, red), p(b, green), p(c, yellow)),  
       (p(a, red), p(c, green), p(b, yellow)),  
       (p(a, yellow), p(b, green), p(c, red)),  
       (p(a, yellow), p(c, green), p(b, red)),  
       (p(b, green), p(a, red), p(c, yellow)),  
       (p(b, green), p(a, yellow), p(c, red)),  
       (p(b, green), p(c, red), p(a, yellow)),  
       (p(b, green), p(c, yellow), p(a, red)),  
       (p(b, red), p(a, green), p(c, yellow)),  
       (p(b, red), p(c, green), p(a, yellow)),  
       (p(b, yellow), p(a, green), p(c, red)),  
       (p(b, yellow), p(c, green), p(a, red)),  
       (p(c, green), p(a, red), p(b, yellow)),  
       (p(c, green), p(a, yellow), p(b, red)),  
       (p(c, green), p(b, red), p(a, yellow)),  
       (p(c, green), p(b, yellow), p(a, red)),  
       (p(c, red), p(a, green), p(b, yellow)),  
       (p(c, red), p(b, green), p(a, yellow)),  
       (p(c, yellow), p(a, green), p(b, red)),  
       (p(c, yellow), p(b, green), p(a, red))].

?- bagof(T, ((all_triplets(_Ts), is_element(T, _Ts), house_info3(T))), _PTs),      
   length(_PTs, L).
L = 24.
\end{verbatim}

It can be seen that {\verb|green|} does not appear in the colour position of the last housing triplet in any of the results.
\newpage

% TASK 7
\subsection{Task 7 - house\_info/1}
\textbf{Source code:}
\begin{verbatim}
house_info((p(P1, C1), p(P2, C2), p(P3, C3))) :-
    house_info1((p(P1, C1), p(P2, C2), p(P3, C3))),
    house_info2((p(P1, C1), p(P2, C2), p(P3, C3))),
    house_info3((p(P1, C1), p(P2, C2), p(P3, C3))).
\end{verbatim}

\textbf{Explanation:} \\
This predicate is a conjunction of the three {\verb|house_infoX/1|} predicates, and so will be true only when ({\verb|house_info1/1|} $\wedge$ {\verb|house_info2/1|} $\wedge$ {\verb|house_info3/1|}) is true. \\

\textbf{Testing:}
\begin{verbatim}
?- house_info((p(c, yellow), p(a, green), p(b, red))).
true .

?- bagof(P, (all_triplets(_Ts), is_element(P, _Ts), \+ house_info(P)), _PT), 
   length(_PT, L).
L = 35.
\end{verbatim}

We can see that the correct solution returns {\verb|true|} when tested, and that the length of the list of solutions that do not fulfil the {\verb|house_info/1|} predicate is 35 - all other solutions.
\newpage

% TASK 8
\subsection{Task 8 - Finding the solution}
\textbf{Interactive session:}
\begin{verbatim}
?- bagof(T, (all_triplets(_Ts), is_element(T, _Ts), house_info(T)), PT).
PT = [(p(c, yellow), p(a, green), p(b, red))].

all_triplets(_Ts), is_element(T, _Ts), house_info(T).
T =  (p(c, yellow), p(a, green), p(b, red)) ;
false.
\end{verbatim}

\textbf{Explanation:} \\
The above interactive session shows that {\verb|(p(c, yellow), p(a, green), p(b, red))|} is the only solution to this problem. In the first example, {\verb|PT|} is unified with a list of only a single element. In the second, Prolog fails to generate any other solution when asked to backtrack with {\verb|;|}. 
\newpage

% Change geometry
\newgeometry{top=1.75cm, bottom=1.75cm, left=0.5cm, right=0.5cm}

%Update actual head width to text width, as geometry doesn't do that
\setlength{\headwidth}{\textwidth}

\section{Appendix}
\subsection{Source code listing}
\begin{verbatim}
%------ DIRECTIVES ...
:- set_prolog_flag(toplevel_print_anon, false).
:- set_prolog_flag(toplevel_print_options, [max_depth(100), portray(true)]).

% I have added this directive because the above did 
% not produce the desired effect on my computer. 

:- set_prolog_flag(
  answer_write_options, 
  [max_depth(100), portray(true), priority(699), spacing(next_argument)]
).

%------ PEOPLE AND COLOURS ...
people([a, b, c]).
cols([green, red, yellow]).

%------ THE PREDICATE is_element/2 ...
is_element(E,[E|_]).
is_element(E,[_|T]) :- is_element(E,T).

%------ TASKS ...
%------ Task 1 - allhousepairs/1 ...

% 1 - The Template, a "house pair", consisting of a tuple containing a person and colour
% 2 - The Goal - contains the variables used to generate pemutations of the Template
% 3 - Unifies P with all elements in the list unified with XS
% 4 - Unifies C with all elements in the list unifies with Ys
% 5 - The Bag, unified with a list of all Template permutations

allhousepairs(Ps) :- 
    bagof(
        p(P, C),                            % 1
        (                                   % 2
           (people(Xs), is_element(P, Xs)), % 3
           (cols(Ys), is_element(C, Ys))    % 4
        ), 
        Ps                                  % 5
    ).
\end{verbatim}

\newpage
\begin{verbatim}
%------ Task 2 - all\_triplets/1 ...

% 1 - The Template, a housing triplet with each a unique name for each variable
% 2 - The Goal (entirety)

% 3 - The Goal (elements) - takes three houses from the list of houses unified with Ps
% 4 - Unifies a list of houses with Ps
% 5 - The first housing triplet
% 6 - The second housing triplet
% 7 - The third housing triplet

% 8 - The Goal (constraints) - checks uniqueness of persons and colours
% 9 - Checks that one person does not own multiple houses
% 10 - Checks that none of the houses are the same colour

% 11 - The Bag, unified with a list of all Template permutations

all_triplets(Ts) :-
    bagof(
        (p(P1, C1), p(P2, C2), p(P3, C3)),    % 1
        (                                     % 2
            (                                 % 3
                allhousepairs(Ps),            % 4
                is_element(p(P1, C1), Ps),    % 5
                is_element(p(P2, C2), Ps),    % 6
                is_element(p(P3, C3), Ps)     % 7
            ),
            (                                 % 8
              (P1 \= P2, P2 \= P3, P3 \= P1), % 9
              (C1 \= C2, C2 \= C3, C3 \= C1)  % 10
            )
       ),
       Ts                                     % 11
   ).

%------ Task 3 - lives_pattern/3

% 1 - Attempts to unify Person and Colour with the person and colour of the first house
% 2 - Attempts to unify Person and Colour with the person and colour of the second house
% 3 - Attempts to unify Person and Colour with the person and colour of the third house

lives_pattern((p(Person, Colour), _, _), Colour, Person). % 1
lives_pattern((_, p(Person, Colour), _), Colour, Person). % 2
lives_pattern((_, _, p(Person, Colour)), Colour, Person). % 3
\end{verbatim}

\newpage
\begin{verbatim}
%------ Task 4 - house info1/1
%  Verify that "A's house is to the right of the yellow house"

% 1 - When the first house is yellow, A may live in the second house...
% 2 - ...or he may live in the third
% 3 - If the second house is yellow, he must live in third. 

house_info1((p(_, C1), p(P2, C2), p(P3, _))) :-
    (C1 = yellow, P2 = a); % 1
    (C1 = yellow, P3 = a); % 2
    (C2 = yellow, P3 = a). % 3
   
%------ Task 5 - house_info2/1
% Verify that "B lives in the red house"

% 1 - Check that the house p(red, b) exists

house_info2((p(P1, C1), p(P2, C2), p(P3, C3))) :-
    lives_pattern((p(P1, C1), p(P2, C2), p(P3, C3)), red, b). % 1

%------ Task 6 - house_info3/1
% Verify that "The green house is not number 3"

% 1 - The colour of the third house is not green

house_info3((p(_, _), p(_, _), p(_, C3))) :-
    C3 \== green. % 1

%------ Task 7 - house_info3/1

% 1 - Check the given housing triplet against house_info1
% 2 - Check the given housing triplet against house_info2
% 3 - Check the given housing triplet against house_info3

house_info((p(P1, C1), p(P2, C2), p(P3, C3))) :-
    house_info1((p(P1, C1), p(P2, C2), p(P3, C3))), % 1
    house_info2((p(P1, C1), p(P2, C2), p(P3, C3))), % 2
    house_info3((p(P1, C1), p(P2, C2), p(P3, C3))). % 4

%------ Task 8
% Task 8 requests an interactive session
\end{verbatim}

\end{document}